package SP20_simulator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;



/**
 * ResourceManager는 컴퓨터의 가상 리소스들을 선언하고 관리하는 클래스이다.
 * 크게 네가지의 가상 자원 공간을 선언하고, 이를 관리할 수 있는 함수들을 제공한다.<br><br>
 * 
 * 1) 입출력을 위한 외부 장치 또는 device<br>
 * 2) 프로그램 로드 및 실행을 위한 메모리 공간. 여기서는 64KB를 최대값으로 잡는다.<br>
 * 3) 연산을 수행하는데 사용하는 레지스터 공간.<br>
 * 4) SYMTAB 등 simulator의 실행 과정에서 사용되는 데이터들을 위한 변수들. 
 * <br><br>
 * 2번은 simulator위에서 실행되는 프로그램을 위한 메모리공간인 반면,
 * 4번은 simulator의 실행을 위한 메모리 공간이라는 점에서 차이가 있다.
 */
public class ResourceManager{
	/**
	 * 디바이스는 원래 입출력 장치들을 의미 하지만 여기서는 파일로 디바이스를 대체한다.<br>
	 * 즉, 'F1'이라는 디바이스는 'F1'이라는 이름의 파일을 의미한다. <br>
	 * deviceManager는 디바이스의 이름을 입력받았을 때 해당 이름의 파일 입출력 관리 클래스를 리턴하는 역할을 한다.
	 * 예를 들어, 'A1'이라는 디바이스에서 파일을 read모드로 열었을 경우, hashMap에 <"A1", scanner(A1)> 등을 넣음으로서 이를 관리할 수 있다.
	 * <br><br>
	 * 변형된 형태로 사용하는 것 역시 허용한다.<br>
	 * 예를 들면 key값으로 String대신 Integer를 사용할 수 있다.
	 * 파일 입출력을 위해 사용하는 stream 역시 자유로이 선택, 구현한다.
	 * <br><br>
	 * 이것도 복잡하면 알아서 구현해서 사용해도 괜찮습니다.
	 */
	HashMap<String,Object> deviceManager = new HashMap<String,Object>();
	ArrayList<String> lockDev /*= new ArrayList<String>()*/; 
	HashMap<String,Integer[]> lockMem /*= new HashMap<String,Integer[]>()*/;
	char[] memory = new char[65536]; // String으로 수정해서 사용하여도 무방함.
	int[] register = new int[10];
	
	SymbolTable symtabList;
	
	// 이외에도 필요한 변수 선언해서 사용할 것.
	static final int A = 0;
	static final int X = 1;
	static final int L = 2;
	static final int B = 3;
	static final int S = 4;
	static final int T = 5;
	static final int F = 6;
	static final int PC = 8;
	static final int SW = 9;
	static final int NONE_FLAG = 0;
	static final int SIGN_FLAG = 1;
	static final int ZERO_FLAG = 2;
	static final int BIG_FLAG = 4;

	static final int REG_SIZE = 3;
	
	static final String ROOT_PATH = System.getProperty("user.dir");
	static final String INPUT_DEV = "F1";
	static final String OUTPUT_DEV = "05";
	
	
	/**
	 * 메모리, 레지스터등 가상 리소스들을 초기화한다.
	 */
	public ResourceManager() {
		initializeResource();
	}
	
	public void initializeResource(){
		try {
			closeDevice();
			lockDev = new ArrayList<String>(); 
			lockMem = new HashMap<String,Integer[]>();
			deviceManager.put(INPUT_DEV, new FileInputStream(ROOT_PATH+"/"+INPUT_DEV));
			deviceManager.put(OUTPUT_DEV, new FileOutputStream(ROOT_PATH+"/"+OUTPUT_DEV));
			symtabList = new SymbolTable();
			this.allocMemory("EXIT", 1, 0);
		}catch(FileNotFoundException e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * deviceManager가 관리하고 있는 파일 입출력 stream들을 전부 종료시키는 역할.
	 * 프로그램을 종료하거나 연결을 끊을 때 호출한다.
	 */
	public void closeDevice() {
		Set sKeySet = deviceManager.keySet(); 
		Iterator<String> i = sKeySet.iterator();
		String curKey;
		
		while(i.hasNext())
		{
			curKey = i.next();
			while(lockDev.contains(curKey));
			deviceManager.remove(curKey);
			i = sKeySet.iterator();
		}
	}
	
	public void putSymbol(String name, int addr) {
		symtabList.putSymbol(name, addr);
	}
	
	public int symbolSearch(String symbol) {
		return symtabList.search(symbol);
	}
	
	public boolean hasUndefinedSymbol() {
		return symtabList.hasUndefinedSymbol();
	}
	
	/**
	 * 디바이스를 사용할 수 있는 상황인지 체크. TD명령어를 사용했을 때 호출되는 함수.
	 * 입출력 stream을 열고 deviceManager를 통해 관리시킨다.
	 * @param devName 확인하고자 하는 디바이스의 번호,또는 이름
	 */
	public void testDevice(String devName) {
		//디바이스가 존재하는지 확인 
		if(!deviceManager.containsKey(devName)) {
			register[SW] = ZERO_FLAG;
			return ;
		}
		//디바이스 lock 여부 확인 
		if(/*devName.contentEquals(INPUT_DEV) &&*/ lockDev.contains(devName)) {
			register[SW] = ZERO_FLAG;
			return;
		}
		else if(/*devName.contentEquals(OUTPUT_DEV) &&*/ lockDev.contains(devName)) {
			register[SW] = ZERO_FLAG;
			return;
		}
		//디바이스 사용 가능 
		register[SW] = SIGN_FLAG;
	}
	

	/**
	 * 디바이스로부터 원하는 개수만큼의 글자를 읽어들인다. RD명령어를 사용했을 때 호출되는 함수.
	 * @param devName 디바이스의 이름
	 * @param num 가져오는 글자의 개수
	 * @return 가져온 데이터
	 */
	public char[] readDevice(String devName, int num){
		byte[] readByteData = new byte[num];
		char[] readCharData = new char[num];
		String toConv;
		
		try {
			if(!devName.contains(INPUT_DEV))
				throw new Exception();
			lockDev.add(INPUT_DEV);
			FileInputStream rd = (FileInputStream)deviceManager.get(devName);
			rd.read(readByteData, 0, num);
			toConv = new String(readByteData, "UTF-8");
			readCharData = toConv.toCharArray();
			lockDev.remove(INPUT_DEV);
		}catch(Exception e) {
			e.printStackTrace();
		}
		
		return readCharData;
		
	}

	/**
	 * 디바이스로 원하는 개수 만큼의 글자를 출력한다. WD명령어를 사용했을 때 호출되는 함수.
	 * @param devName 디바이스의 이름
	 * @param data 보내는 데이터
	 * @param num 보내는 글자의 개수
	 */
	public void writeDevice(String devName, char[] data, int num){
		String toConv;
		byte[] baWrData = new byte[data.length];
		int tmp;
		byte btmp;
		try {
			if(!devName.contains(OUTPUT_DEV))
				throw new Exception();
			lockDev.add(OUTPUT_DEV);
			FileOutputStream wr = (FileOutputStream)deviceManager.get(devName);
			//baWrData = SicLoader.convertCharArrToByteArr(data);
			//int tmp;
			for(int i=0;i<data.length;i++)
			{
				tmp = (byte)(baWrData[i]|((data[i]&0xF00)>>4));
				btmp = (byte)(baWrData[i]|((data[i]&0xF00)>>4));
				baWrData[i] = (byte)(data[i]&(0xF));
				baWrData[i] = (byte) (baWrData[i]|((data[i]&0xF00)>>4));
			}
			baWrData = Arrays.copyOfRange(baWrData, baWrData.length-num, baWrData.length);
			wr.write(baWrData, 0, num);
			wr.flush();
			lockDev.remove(OUTPUT_DEV);
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	public int getAvailMemoryAddr(int progSize) {
		Iterator<String> it = ResourceManager.sortByValue(lockMem).iterator();
		String curKey;
		Integer[] prevProg = new Integer[] {0,0};
		Integer[] curProg = new Integer[2];
		
		while(it.hasNext() && (prevProg[1]+progSize)<65536) {
			curKey = it.next();
			curProg = lockMem.get(curKey);
			if(curProg[0]-prevProg[1] >= progSize)
			{
				break;
			}
			prevProg = curProg;
		}
		
		if(prevProg[1]+progSize < 65536)
		{
			return prevProg[1];
		}
		return -1;
	
		
	}
	
	public void allocMemory(String progName,int progSize, int allocAddr) {
	
		Integer[] procSect = new Integer[] {allocAddr, allocAddr+progSize};
		lockMem.put(progName, procSect);
	}
	
	
	/**
	 *특정 메모리 공간을 할당하기 전에 어떤 메모리 공간을 할당할지 알아내기 위해 기존에 할당 한 메모리 공간을 시작 주소를 기준으로 
	 *정렬 하기위해 HashMap을 정렬할 필요가 있는데 이러한 기능을 수행해주는 함수 
	 **/
	public static List sortByValue(HashMap<String,Integer[]> map) {
		List<String> listKey = new ArrayList();
		listKey.addAll(map.keySet());
		
		Collections.sort(listKey,new Comparator() {
			public int compare(Object o1, Object o2) {
				Object[] v1 = map.get(o1);
				Object[] v2 = map.get(o2);
				
				return ((Comparable)v2[0]).compareTo(v1[0]);
			}
		});
		
		Collections.reverse(listKey);
		return listKey;
	}
	
	public void freeMemory(String progName)
	{
		lockMem.remove(progName);
	}
	
	/**
	 * 메모리의 특정 위치에서 원하는 개수만큼의 글자를 가져온다.
	 * @param location 메모리 접근 위치 인덱스
	 * @param num 데이터 개수
	 * @return 가져오는 데이터
	 */
	public char[] getMemory(int locate, int num){
		char[] caReadData = Arrays.copyOfRange(memory, locate, locate+num);

		
	

		return caReadData;
	}

	/**
	 * 메모리의 특정 위치에 원하는 개수만큼의 데이터를 저장한다. 
	 * @param locate 접근 위치 인덱스
	 * @param data 저장하려는 데이터
	 * @param num 저장하는 데이터의 개수
	 */
	public void setMemory(int locate, char[] data, int num){

		for(int i=0,j=data.length-num;j<data.length;i++,j++)
		{
			memory[locate+i] = (char)data[j];
		}
	}

	/**
	 * 번호에 해당하는 레지스터가 현재 들고 있는 값을 리턴한다. 레지스터가 들고 있는 값은 문자열이 아님에 주의한다.
	 * @param regNum 레지스터 분류번호
	 * @return 레지스터가 소지한 값
	 */
	public int getRegister(int regNum){
		return register[regNum];
	}

	/**
	 * 번호에 해당하는 레지스터에 새로운 값을 입력한다. 레지스터가 들고 있는 값은 문자열이 아님에 주의한다.
	 * @param regNum 레지스터의 분류번호
	 * @param value 레지스터에 집어넣는 값
	 */
	public void setRegister(int regNum, int value){
		register[regNum] = value;
	}

	/*
	 * 번호에 해당하는 레지스터의 지정된 크기 만큼의 데이터를 
	 * 지정된 주소의 메모리에  저장
	 * @param regNum 레지스터의 분류 번호
	 * @param location 값을 넣을 메모리의 시작 위치
	 * @param len 레지스터에서 읽어올 데이터의 크기
	 */
	public void storeRegister(int regNum, int locate, int num)
	{
		char[] caData = intToChar(getRegister(regNum));
		
		setMemory(locate, caData, num);
	}
	/*
	*/
	public void loadMemory(int regNum, int locate, int num)
	{
		try {
			if(num>REG_SIZE)
				throw new IllegalArgumentException();
			int loadVal = charToInt(getMemory(locate,num));
			setRegister(regNum, loadVal);
		}catch(IllegalArgumentException e)
		{
			e.printStackTrace();
		}
	}
	/**
	 * 주로 레지스터와 메모리간의 데이터 교환에서 사용된다. int값을 char[]형태로 변경한다.
	 * @param data
	 * @return
	 */
	public char[] intToChar(int data){
		char[] caData = new char[4];

		caData[0] = (char) ((data & 0xF0000000)>>20);
		caData[0] |= (char) ((data & 0xF000000)>>24);
		caData[1] = (char) ((data & 0xF00000)>>12);
		caData[1] |= (char) ((data & 0xF0000)>>16);
		caData[2] = (char) ((data & 0xF000)>>4);
		caData[2] |= (char) ((data & 0xF00)>>8);
		caData[3] = (char) ((data & 0xF0)<<4);
		caData[3] |= (char) (data & 0xF);
		
		return caData;
	}

	/**
	 * 주로 레지스터와 메모리간의 데이터 교환에서 사용된다. char[]값을 int형태로 변경한다.
	 * @param data
	 * @return
	 */
	public int charToInt(char[] data){
		int iData = 0;
		int tmp = 0;
		try {
			if(data.length > 4)
				throw new IllegalArgumentException();
			for(int i=0;i<data.length;i++)
			{
				iData = iData << 8;
				iData = (iData) |  (data[i] & 0xFF);
				tmp = (data[i] & 0xFF);
				iData = (iData) |  (((data[i]>>8) & 0xFF)<<4);
				tmp = ((((data[i]>>8) & 0xFF)<<4));
				
			}
		}catch(IllegalArgumentException e)
		{
			e.printStackTrace();
		}
		
		return iData;
	}

}